// Mocks generated by Mockito 5.4.6 from annotations
// in sjgtv/test/src/source/provider/sources_provider_test.dart.
// Do not manually edit this file.

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'dart:async' as _i2;
import 'dart:typed_data' as _i5;

import 'package:isar_community/isar.dart' as _i3;
import 'package:mockito/mockito.dart' as _i1;
import 'package:mockito/src/dummies.dart' as _i4;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: deprecated_member_use
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: must_be_immutable
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types
// ignore_for_file: subtype_of_sealed_class

class _FakeFuture_0<T1> extends _i1.SmartFake implements _i2.Future<T1> {
  _FakeFuture_0(Object parent, Invocation parentInvocation)
    : super(parent, parentInvocation);
}

class _FakeIsarCollection_1<OBJ> extends _i1.SmartFake
    implements _i3.IsarCollection<OBJ> {
  _FakeIsarCollection_1(Object parent, Invocation parentInvocation)
    : super(parent, parentInvocation);
}

class _FakeIsar_2 extends _i1.SmartFake implements _i3.Isar {
  _FakeIsar_2(Object parent, Invocation parentInvocation)
    : super(parent, parentInvocation);
}

/// A class which mocks [Isar].
///
/// See the documentation for Mockito's code generation for more information.
class MockIsar extends _i1.Mock implements _i3.Isar {
  MockIsar() {
    _i1.throwOnMissingStub(this);
  }

  @override
  String get name =>
      (super.noSuchMethod(
            Invocation.getter(#name),
            returnValue: _i4.dummyValue<String>(this, Invocation.getter(#name)),
          )
          as String);

  @override
  bool get isOpen =>
      (super.noSuchMethod(Invocation.getter(#isOpen), returnValue: false)
          as bool);

  @override
  void requireOpen() => super.noSuchMethod(
    Invocation.method(#requireOpen, []),
    returnValueForMissingStub: null,
  );

  @override
  _i2.Future<T> txn<T>(_i2.Future<T> Function()? callback) =>
      (super.noSuchMethod(
            Invocation.method(#txn, [callback]),
            returnValue:
                _i4.ifNotNull(
                  _i4.dummyValueOrNull<T>(
                    this,
                    Invocation.method(#txn, [callback]),
                  ),
                  (T v) => _i2.Future<T>.value(v),
                ) ??
                _FakeFuture_0<T>(this, Invocation.method(#txn, [callback])),
          )
          as _i2.Future<T>);

  @override
  _i2.Future<T> writeTxn<T>(
    _i2.Future<T> Function()? callback, {
    bool? silent = false,
  }) =>
      (super.noSuchMethod(
            Invocation.method(#writeTxn, [callback], {#silent: silent}),
            returnValue:
                _i4.ifNotNull(
                  _i4.dummyValueOrNull<T>(
                    this,
                    Invocation.method(#writeTxn, [callback], {#silent: silent}),
                  ),
                  (T v) => _i2.Future<T>.value(v),
                ) ??
                _FakeFuture_0<T>(
                  this,
                  Invocation.method(#writeTxn, [callback], {#silent: silent}),
                ),
          )
          as _i2.Future<T>);

  @override
  T txnSync<T>(T Function()? callback) =>
      (super.noSuchMethod(
            Invocation.method(#txnSync, [callback]),
            returnValue: _i4.dummyValue<T>(
              this,
              Invocation.method(#txnSync, [callback]),
            ),
          )
          as T);

  @override
  T writeTxnSync<T>(T Function()? callback, {bool? silent = false}) =>
      (super.noSuchMethod(
            Invocation.method(#writeTxnSync, [callback], {#silent: silent}),
            returnValue: _i4.dummyValue<T>(
              this,
              Invocation.method(#writeTxnSync, [callback], {#silent: silent}),
            ),
          )
          as T);

  @override
  void attachCollections(Map<Type, _i3.IsarCollection<dynamic>>? collections) =>
      super.noSuchMethod(
        Invocation.method(#attachCollections, [collections]),
        returnValueForMissingStub: null,
      );

  @override
  _i3.IsarCollection<T> collection<T>() =>
      (super.noSuchMethod(
            Invocation.method(#collection, []),
            returnValue: _FakeIsarCollection_1<T>(
              this,
              Invocation.method(#collection, []),
            ),
          )
          as _i3.IsarCollection<T>);

  @override
  _i3.IsarCollection<dynamic>? getCollectionByNameInternal(String? name) =>
      (super.noSuchMethod(
            Invocation.method(#getCollectionByNameInternal, [name]),
          )
          as _i3.IsarCollection<dynamic>?);

  @override
  _i2.Future<void> clear() =>
      (super.noSuchMethod(
            Invocation.method(#clear, []),
            returnValue: _i2.Future<void>.value(),
            returnValueForMissingStub: _i2.Future<void>.value(),
          )
          as _i2.Future<void>);

  @override
  void clearSync() => super.noSuchMethod(
    Invocation.method(#clearSync, []),
    returnValueForMissingStub: null,
  );

  @override
  _i2.Future<int> getSize({
    bool? includeIndexes = false,
    bool? includeLinks = false,
  }) =>
      (super.noSuchMethod(
            Invocation.method(#getSize, [], {
              #includeIndexes: includeIndexes,
              #includeLinks: includeLinks,
            }),
            returnValue: _i2.Future<int>.value(0),
          )
          as _i2.Future<int>);

  @override
  int getSizeSync({bool? includeIndexes = false, bool? includeLinks = false}) =>
      (super.noSuchMethod(
            Invocation.method(#getSizeSync, [], {
              #includeIndexes: includeIndexes,
              #includeLinks: includeLinks,
            }),
            returnValue: 0,
          )
          as int);

  @override
  _i2.Future<void> copyToFile(String? targetPath) =>
      (super.noSuchMethod(
            Invocation.method(#copyToFile, [targetPath]),
            returnValue: _i2.Future<void>.value(),
            returnValueForMissingStub: _i2.Future<void>.value(),
          )
          as _i2.Future<void>);

  @override
  _i2.Future<bool> close({bool? deleteFromDisk = false}) =>
      (super.noSuchMethod(
            Invocation.method(#close, [], {#deleteFromDisk: deleteFromDisk}),
            returnValue: _i2.Future<bool>.value(false),
          )
          as _i2.Future<bool>);

  @override
  _i2.Future<void> verify() =>
      (super.noSuchMethod(
            Invocation.method(#verify, []),
            returnValue: _i2.Future<void>.value(),
            returnValueForMissingStub: _i2.Future<void>.value(),
          )
          as _i2.Future<void>);
}

/// A class which mocks [QueryBuilder].
///
/// See the documentation for Mockito's code generation for more information.
class MockQueryBuilder<OBJ, R, S> extends _i1.Mock
    implements _i3.QueryBuilder<OBJ, R, S> {
  MockQueryBuilder() {
    _i1.throwOnMissingStub(this);
  }
}

/// A class which mocks [Query].
///
/// See the documentation for Mockito's code generation for more information.
class MockQuery<T> extends _i1.Mock implements _i3.Query<T> {
  MockQuery() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i3.Isar get isar =>
      (super.noSuchMethod(
            Invocation.getter(#isar),
            returnValue: _FakeIsar_2(this, Invocation.getter(#isar)),
          )
          as _i3.Isar);

  @override
  _i2.Future<T?> findFirst() =>
      (super.noSuchMethod(
            Invocation.method(#findFirst, []),
            returnValue: _i2.Future<T?>.value(),
          )
          as _i2.Future<T?>);

  @override
  _i2.Future<List<T>> findAll() =>
      (super.noSuchMethod(
            Invocation.method(#findAll, []),
            returnValue: _i2.Future<List<T>>.value(<T>[]),
          )
          as _i2.Future<List<T>>);

  @override
  List<T> findAllSync() =>
      (super.noSuchMethod(
            Invocation.method(#findAllSync, []),
            returnValue: <T>[],
          )
          as List<T>);

  @override
  _i2.Future<R?> aggregate<R>(_i3.AggregationOp? op) =>
      (super.noSuchMethod(
            Invocation.method(#aggregate, [op]),
            returnValue: _i2.Future<R?>.value(),
          )
          as _i2.Future<R?>);

  @override
  R? aggregateSync<R>(_i3.AggregationOp? op) =>
      (super.noSuchMethod(Invocation.method(#aggregateSync, [op])) as R?);

  @override
  _i2.Future<int> count() =>
      (super.noSuchMethod(
            Invocation.method(#count, []),
            returnValue: _i2.Future<int>.value(0),
          )
          as _i2.Future<int>);

  @override
  int countSync() =>
      (super.noSuchMethod(Invocation.method(#countSync, []), returnValue: 0)
          as int);

  @override
  _i2.Future<bool> isEmpty() =>
      (super.noSuchMethod(
            Invocation.method(#isEmpty, []),
            returnValue: _i2.Future<bool>.value(false),
          )
          as _i2.Future<bool>);

  @override
  bool isEmptySync() =>
      (super.noSuchMethod(
            Invocation.method(#isEmptySync, []),
            returnValue: false,
          )
          as bool);

  @override
  _i2.Future<bool> isNotEmpty() =>
      (super.noSuchMethod(
            Invocation.method(#isNotEmpty, []),
            returnValue: _i2.Future<bool>.value(false),
          )
          as _i2.Future<bool>);

  @override
  bool isNotEmptySync() =>
      (super.noSuchMethod(
            Invocation.method(#isNotEmptySync, []),
            returnValue: false,
          )
          as bool);

  @override
  _i2.Future<bool> deleteFirst() =>
      (super.noSuchMethod(
            Invocation.method(#deleteFirst, []),
            returnValue: _i2.Future<bool>.value(false),
          )
          as _i2.Future<bool>);

  @override
  bool deleteFirstSync() =>
      (super.noSuchMethod(
            Invocation.method(#deleteFirstSync, []),
            returnValue: false,
          )
          as bool);

  @override
  _i2.Future<int> deleteAll() =>
      (super.noSuchMethod(
            Invocation.method(#deleteAll, []),
            returnValue: _i2.Future<int>.value(0),
          )
          as _i2.Future<int>);

  @override
  int deleteAllSync() =>
      (super.noSuchMethod(Invocation.method(#deleteAllSync, []), returnValue: 0)
          as int);

  @override
  _i2.Stream<List<T>> watch({bool? fireImmediately = false}) =>
      (super.noSuchMethod(
            Invocation.method(#watch, [], {#fireImmediately: fireImmediately}),
            returnValue: _i2.Stream<List<T>>.empty(),
          )
          as _i2.Stream<List<T>>);

  @override
  _i2.Stream<void> watchLazy({bool? fireImmediately = false}) =>
      (super.noSuchMethod(
            Invocation.method(#watchLazy, [], {
              #fireImmediately: fireImmediately,
            }),
            returnValue: _i2.Stream<void>.empty(),
          )
          as _i2.Stream<void>);

  @override
  _i2.Future<R> exportJsonRaw<R>(R Function(_i5.Uint8List)? callback) =>
      (super.noSuchMethod(
            Invocation.method(#exportJsonRaw, [callback]),
            returnValue:
                _i4.ifNotNull(
                  _i4.dummyValueOrNull<R>(
                    this,
                    Invocation.method(#exportJsonRaw, [callback]),
                  ),
                  (R v) => _i2.Future<R>.value(v),
                ) ??
                _FakeFuture_0<R>(
                  this,
                  Invocation.method(#exportJsonRaw, [callback]),
                ),
          )
          as _i2.Future<R>);

  @override
  R exportJsonRawSync<R>(R Function(_i5.Uint8List)? callback) =>
      (super.noSuchMethod(
            Invocation.method(#exportJsonRawSync, [callback]),
            returnValue: _i4.dummyValue<R>(
              this,
              Invocation.method(#exportJsonRawSync, [callback]),
            ),
          )
          as R);

  @override
  _i2.Future<List<Map<String, dynamic>>> exportJson() =>
      (super.noSuchMethod(
            Invocation.method(#exportJson, []),
            returnValue: _i2.Future<List<Map<String, dynamic>>>.value(
              <Map<String, dynamic>>[],
            ),
          )
          as _i2.Future<List<Map<String, dynamic>>>);

  @override
  List<Map<String, dynamic>> exportJsonSync() =>
      (super.noSuchMethod(
            Invocation.method(#exportJsonSync, []),
            returnValue: <Map<String, dynamic>>[],
          )
          as List<Map<String, dynamic>>);
}
